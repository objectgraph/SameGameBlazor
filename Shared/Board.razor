<div class="row">
    <div class="col-md-3">
        <button class="btn btn-outline-primary" @onclick="()=>Undo()">Undo</button>
         <button class="btn btn-outline-primary" @onclick="()=>Redo()">Redo</button>
    </div>
    <div class="col-md-3">
        Score: @score
    </div>
    <div class="col-md-3">
        Selection: @currentSelection
    </div>
    <div class="col-md-3">
        GameOver: @gameOver
    </div>
</div>
<svg width="@Width" height="@Height">
    @for(int i=0;i<Rows;i++){
        @for(int j=0;j<Cols;j++){
           var obj = Data[i,j];
            <g transform="translate(@(j*cellWidth),@(i*cellWidth))">
            <rect x=0 y=0 width="@cellWidth" height="@cellWidth" fill="white" @onclick="()=>Action(obj)"></rect>
            @if(!obj.Deleted){
                @if(obj.Selected){
                    <rect x=0 y=0 width="@cellWidth" height="@cellWidth" fill="lightgrey" @onclick="()=>Action(obj)"></rect>
                }
                <circle cx="@(cellWidth/2)" cy="@(cellWidth/2)" r="@(cellWidth/2-2)" fill="@Data[i,j].Color" @onclick="()=>Action(obj)"></circle>
            }
            @* <text x="@(cellWidth/2)" y="@(cellWidth/2)">(@obj.Row,@obj.Col)</text> *@
            </g>

        }
    }
</svg>
@code{
    [Parameter] public int Width{get;set;}=500;
    [Parameter] public int Height{get;set;}=500;
    [Parameter] public int Rows{get;set;}=10;
    [Parameter] public int Cols{get;set;}=10;
    [Parameter] public int Colors{get;set;}=5;
    int cellWidth = 0;
    public record struct Cell(int Row, int Col, string Color,bool Selected,bool Deleted);   
    public Cell[,] Data{get;set;}
    Stack<string> undoStack = new Stack<string>();
    Stack<string> redoStack = new Stack<string>();

    public int currentSelection= 0;
    public int score = 0;
    public bool gameOver = false;
    protected override void OnInitialized() {
        base.OnInitialized();
        cellWidth = Width/Cols;
        Data = new Cell[Rows,Cols]; 
        NewGame();
    }

    public string Serialize(){
        return JsonConvert.SerializeObject(Data);
    }

    public void DeSerialize(string data){
        Data = JsonConvert.DeserializeObject<Cell[,]>(data);
    }


    public void NewGame(){
        this.currentSelection = 0;
        this.score = 0;
        this.undoStack.Clear();
        this.redoStack.Clear();
        var random = new Random();
        for(int i=0;i<Rows;i++){
            for(int j=0;j<Cols;j++){
                var color = random.Next()%Colors;
                string cl = null;
                if(color==0){
                    cl= "red";
                }
                else if(color==1){
                    cl= "green";
                }
                else if(color==2){
                    cl= "darkorange";
                }
                else if(color==3){
                    cl= "brown";
                }
                else if(color==4){
                    cl= "purple";
                }
                Data[i,j]= new Cell(i,j,cl,false,false);
            }    
        }
        StateHasChanged();
    }

    private void PrintState(string message=""){
        if(!string.IsNullOrEmpty(message)){
            Console.WriteLine(message);
        }
         for(int i=0;i<Rows;i++){
            for(int j=0;j<Cols;j++){
                Console.Write(Data[i,j]);
            }
            Console.WriteLine();
         }
    }
    private bool isValid (int row, int col){
        return row >= 0 && row < Rows && col >= 0 && col < Cols;
    }
    private void  getSameColorNeighbors (List<Cell> arr, Cell cell) {
        int row = cell.Row;
        int col = cell.Col;
        //south
        if (this.isValid(row + 1, col) && !Data[row + 1,col].Deleted && Data[row + 1,col].Color == cell.Color && !arr.Contains(Data[row + 1,col])) {
            arr.Add(Data[row + 1,col]);
            this.getSameColorNeighbors(arr, Data[row + 1,col]);
        }
        //east
        if (this.isValid(row, col + 1) && !Data[row,col + 1].Deleted && Data[row,col + 1].Color == cell.Color && !arr.Contains(Data[row,col + 1])) {
            arr.Add(Data[row,col + 1]);
            this.getSameColorNeighbors(arr, Data[row,col + 1]);
        }

        //north
        if (this.isValid(row - 1, col) && !Data[row - 1,col].Deleted && Data[row - 1,col].Color == cell.Color && !arr.Contains(Data[row - 1,col])) {
            arr.Add(Data[row - 1,col]);
            this.getSameColorNeighbors(arr, Data[row - 1,col]);
        }

        //west
        if (this.isValid(row, col - 1) && !Data[row,col - 1].Deleted && Data[row,col - 1].Color == cell.Color && !arr.Contains(Data[row,col - 1])) {
            arr.Add(Data[row,col - 1]);
            this.getSameColorNeighbors(arr, Data[row,col - 1]);
        }
    }
     private void Action(Cell cell){
        var arr = new List<Cell>();
        this.getSameColorNeighbors(arr, cell);
        if (arr.Count > 0) {
            if (cell.Selected) {
                this.redoStack.Clear();
                this.undoStack.Push(Serialize());
                this.score = this.score + ((arr.Count) * (arr.Count - 1) * 10);
                arr.ForEach((obj) => Data[obj.Row,obj.Col].Deleted = true );
                this.currentSelection = 0;
            }
            else {
                for(int i=0;i<Rows;i++){
                    for(int j=0;j<Cols;j++){
                        Data[i,j].Selected=false;
                    }
                }
                arr.ForEach((obj) => Data[obj.Row,obj.Col].Selected = true );
                this.currentSelection = (arr.Count) * (arr.Count - 1) * 10;
            }
            this.Gravity();
            this.Compact();
            this.gameOver = this.DetectGameOver();
            StateHasChanged();
        }
    }
     private void Gravity (){
        for (var j = this.Cols - 1; j >= 0; j--) {
            for (var i = this.Rows - 1; i >= 1; i--) {
                if (this.Data[i,j].Deleted) {
                    //find first non empty cell and exchange
                    var r = i - 1;
                    while (this.Data[r,j].Deleted && r > 0) {
                        r--;
                    }
                    if (!this.Data[r,j].Deleted) {
                        //exchange
                        this.Swap(i, j, r, j);
                    }
                }
            }
        }

    }
    private void Compact (){
        for (var j = this.Cols - 1; j >= 1; j--) {
            if (this.ColEmpty(j)) {
                //find lowest column that is non empty
                var col = j - 1;
                while (this.ColEmpty(col) && col > 0) {
                    col--;
                }
                for (var i = 0; i < this.Rows; i++) {
                    this.Swap(i, j, i, col);
                }
            }
        }
    }
    private bool ColEmpty (int col) {
        for (int i = 0; i < Rows; i++) {
            if (!Data[i,col].Deleted) {
                return false;
            }
        }
        return true;
    }
    private bool DetectGameOver () {
        for (int i = 0; i < this.Rows; i++) {
            for (int j = 0; j < this.Cols; j++) {
                if (Data[i,j].Deleted) {
                    continue;
                }
                var color = Data[i,j].Color;
                if ((this.isValid(i - 1, j) && !Data[i - 1,j].Deleted && Data[i - 1,j].Color == color)
                    || (this.isValid(i, j + 1) && !Data[i,j + 1].Deleted && Data[i,j + 1].Color == color)
                    || (this.isValid(i + 1, j) && !Data[i + 1,j].Deleted && Data[i + 1,j].Color == color)
                    || (this.isValid(i, j - 1) && !Data[i,j - 1].Deleted && Data[i,j - 1].Color == color)) {
                    return false;
                }
            }
        }
        return true;
    }
    void Swap( int i, int j, int k, int l) {
        string tColor = Data[i,j].Color;
        bool tSelected = Data[i,j].Selected;
        bool tDeleted = Data[i,j].Deleted;

        Data[i,j].Color = Data[k,l].Color;
        Data[i,j].Selected = Data[k,l].Selected;
        Data[i,j].Deleted = Data[k,l].Deleted;
        
        Data[k,l].Color = tColor;
        Data[k,l].Selected = tSelected;
        Data[k,l].Deleted = tDeleted;
        
    }

    private int LiveCellCount(){
        var cellCount = 0;
         for (int i = 0; i < this.Rows; i++) {
            for (int j = 0; j < this.Cols; j++) {
                if (!Data[i,j].Deleted) {
                    cellCount++;
                }
            }
        }
        return cellCount;
    }

    private void Undo() {
        if (this.undoStack.Count > 0) {
            var nowLiveCount = this.LiveCellCount();
            this.redoStack.Push(Serialize());
            var data = undoStack.Pop();
            DeSerialize(data);
            var afterUndoLiveCount = this.LiveCellCount();
            var diff = afterUndoLiveCount - nowLiveCount;
            this.score = this.score - (diff * (diff - 1) * 10);
            this.gameOver = this.DetectGameOver();
            StateHasChanged();
        }
    }

    private void Redo(){
        if (this.redoStack.Count > 0) {
            var nowLiveCount = this.LiveCellCount();
            this.undoStack.Push(Serialize());
            var data = redoStack.Pop();
            DeSerialize(data);
            var afterUndoLiveCount = this.LiveCellCount();
            var diff = nowLiveCount - afterUndoLiveCount;
            this.score = this.score + (diff * (diff - 1) * 10);
            this.gameOver = this.DetectGameOver();
            StateHasChanged();
        }
    }

}