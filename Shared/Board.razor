<div class="row">
    <div class="col-md-3">
        Score: @score
    </div>
    <div class="col-md-3">
        Selection: @currentSelection
    </div>
    <div class="col-md-3">
        GameOver: @gameOver
    </div>
</div>
<svg width="@Width" height="@Height">
    @for(int i=0;i<Rows;i++){
        @for(int j=0;j<Cols;j++){
           var obj = Data[i,j];
            <g transform="translate(@(j*cellWidth),@(i*cellWidth))" @onclick="()=>Action(obj)">
            @if(!obj.Deleted){
                @if(obj.Selected){
                    <rect x=0 y=0 width="@cellWidth" height="@cellWidth" fill="lightgrey"></rect>
                }
                <circle cx="@(cellWidth/2)" cy="@(cellWidth/2)" r="@(cellWidth/2)" fill="@Data[i,j].Color"></circle>
            }
            <text x="@(cellWidth/2)" y="@(cellWidth/2)">(@obj.Row,@obj.Col)</text>
            </g>

        }
    }
</svg>
@code{
    [Parameter] public int Width{get;set;}=500;
    [Parameter] public int Height{get;set;}=500;
    [Parameter] public int Rows{get;set;}=10;
    [Parameter] public int Cols{get;set;}=10;
    [Parameter] public int Colors{get;set;}=5;
    int cellWidth = 0;
    public record struct Cell(int Row, int Col, string Color,bool Selected,bool Deleted);   
    public Cell[,] Data{get;set;}

    public int currentSelection= 0;
    public int score = 0;
    public bool gameOver = false;
    protected override void OnInitialized() {
        base.OnInitialized();
        cellWidth = Width/Cols;
        Data = new Cell[Rows,Cols]; 
        NewGame();
    }
    public void NewGame(){
        var random = new Random();
        for(int i=0;i<Rows;i++){
            for(int j=0;j<Cols;j++){
                var color = random.Next()%Colors;
                string cl = null;
                if(color==0){
                    cl= "red";
                }
                else if(color==1){
                    cl= "green";
                }
                else if(color==2){
                    cl= "darkorange";
                }
                else if(color==3){
                    cl= "brown";
                }
                else if(color==4){
                    cl= "purple";
                }
                Data[i,j]= new Cell(i,j,cl,false,false);
            }    
        }
        StateHasChanged();
    }

    private void PrintState(){
         for(int i=0;i<Rows;i++){
            for(int j=0;j<Cols;j++){
                Console.WriteLine(Data[i,j]);
            }
         }
    }
    private bool isValid (int row, int col){
        return row >= 0 && row < Rows && col >= 0 && col < Cols;
    }
    private void  getSameColorNeighbors (List<Cell> arr, Cell cell) {
        int row = cell.Row;
        int col = cell.Col;
        //south
        if (this.isValid(row + 1, col) && !Data[row + 1,col].Deleted && Data[row + 1,col].Color == cell.Color && !arr.Contains(Data[row + 1,col])) {
            arr.Add(Data[row + 1,col]);
            this.getSameColorNeighbors(arr, Data[row + 1,col]);
        }
        //east
        if (this.isValid(row, col + 1) && !Data[row,col + 1].Deleted && Data[row,col + 1].Color == cell.Color && !arr.Contains(Data[row,col + 1])) {
            arr.Add(Data[row,col + 1]);
            this.getSameColorNeighbors(arr, Data[row,col + 1]);
        }

        //north
        if (this.isValid(row - 1, col) && !Data[row - 1,col].Deleted && Data[row - 1,col].Color == cell.Color && !arr.Contains(Data[row - 1,col])) {
            arr.Add(Data[row - 1,col]);
            this.getSameColorNeighbors(arr, Data[row - 1,col]);
        }

        //west
        if (this.isValid(row, col - 1) && !Data[row,col - 1].Deleted && Data[row,col - 1].Color == cell.Color && !arr.Contains(Data[row,col - 1])) {
            arr.Add(Data[row,col - 1]);
            this.getSameColorNeighbors(arr, Data[row,col - 1]);
        }
    }
     private void Action(Cell cell){
        var arr = new List<Cell>();
        this.getSameColorNeighbors(arr, cell);
        if (arr.Count > 0) {
            if (cell.Selected) {
                @* this.redoStack = [];
                this.undoStack.push(JSON.parse(JSON.stringify(this.data))); *@
                @* this.score = this.score + ((arr.length) * (arr.length - 1) * 10) *@
                arr.ForEach((obj) => Data[obj.Row,obj.Col].Deleted = true );
                this.currentSelection = 0;
            }
            else {
                for(int i=0;i<Rows;i++){
                    for(int j=0;j<Cols;j++){
                        Data[i,j].Selected=false;
                    }
                }
                arr.ForEach((obj) => Data[obj.Row,obj.Col].Selected = true );
                this.currentSelection = (arr.Count) * (arr.Count - 1) * 10;
            }
            this.Gravity();
            @* this.Compact(); *@
            this.gameOver = this.DetectGameOver();
            StateHasChanged();
        }
    }
     private void Gravity (){
        for (var j = this.Cols - 1; j >= 0; j--) {
            for (var i = this.Rows - 1; i >= 1; i--) {
                if (this.Data[i,j].Deleted) {
                    //find first non empty cell and exchange
                    var r = i - 1;
                    while (this.Data[r,j].Deleted && r > 0) {
                        r--;
                    }
                    if (!this.Data[r,j].Deleted) {
                        //exchange
                        this.Swap(i, j, r, j);
                    }
                }
            }
        }

    }
    private void Compact (){
        for (var j = this.Cols - 1; j >= 1; j--) {
            if (this.ColEmpty(j)) {
                //find lowest column that is non empty
                var col = j - 1;
                while (this.ColEmpty(col) && col > 0) {
                    col--;
                }
                for (var i = 0; i < this.Rows; i++) {
                    this.Swap(i, j, i, col);
                }
            }
        }
    }
    private bool ColEmpty (int col) {
        for (int i = 0; i < Rows; i++) {
            if (!Data[i,col].Deleted) {
                return false;
            }
        }
        return true;
    }
    private bool DetectGameOver () {
        for (int i = 0; i < this.Rows; i++) {
            for (int j = 0; j < this.Cols; j++) {
                if (Data[i,j].Deleted) {
                    continue;
                }
                var color = Data[i,j].Color;
                if ((this.isValid(i - 1, j) && !Data[i - 1,j].Deleted && Data[i - 1,j].Color == color)
                    || (this.isValid(i, j + 1) && !Data[i,j + 1].Deleted && Data[i,j + 1].Color == color)
                    || (this.isValid(i + 1, j) && !Data[i + 1,j].Deleted && Data[i + 1,j].Color == color)
                    || (this.isValid(i, j - 1) && !Data[i,j - 1].Deleted && Data[i,j - 1].Color == color)) {
                    return false;
                }
            }
        }
        return true;
    }
    void Swap( int i, int j, int k, int l) {
        int trow = Data[i,j].Row;
        int tcol = Data[i,j].Col;

        Data[i,j].Row = Data[k,l].Row;
        Data[i,j].Col = Data[k,l].Col;
        Data[k,l].Row = trow;
        Data[k,l].Col = tcol;
        var temp = Data[i,j];
        Data[i,j] = Data[k,l];
        Data[k,j] = temp;
    }

}